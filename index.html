<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Duck Scene</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #5CCCFF; /* Light blue to match sky */
            font-family: Arial, sans-serif;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .ui-button {
            pointer-events: auto;
            position: absolute;
            padding: 15px 30px;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #333;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            color: #333;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
        }

        .ui-button:hover {
            background: rgba(255, 255, 255, 1);
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        #startButton {
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
        }

        #debugButton {
            bottom: 50px;
            left: calc(50% + 120px);
            transform: translateX(-50%);
        }

        /* Dialogue bubble styles */
        #dialogueBubble {
            pointer-events: none;
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #333;
            border-radius: 15px;
            padding: 15px;
            max-width: 300px;
            font-size: 16px;
            color: #333;
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s ease;
            z-index: 150;
            transform: translate(-50%, -100%);
            margin-top: -20px;
        }

        #dialogueBubble:after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            width: 0;
            height: 0;
            border: 10px solid transparent;
            border-top-color: #333;
            border-bottom: 0;
            margin-left: -10px;
        }

        /* Cloud counter styles */
        #cloudCounter {
            display: none; /* Hide the cloud counter since we're using the dialogue bubble instead */
            pointer-events: none;
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.8);
            border: 2px solid #333;
            border-radius: 8px;
            padding: 10px 15px;
            font-size: 16px;
            font-weight: bold;
            color: #333;
            z-index: 150;
        }

        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            color: #fff;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid #333;
            border-top: 3px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .ui-button {
                padding: 12px 24px;
                font-size: 16px;
            }

            #startButton {
                bottom: 30px;
            }

            #dialogueBubble {
                max-width: 250px;
                font-size: 14px;
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="ui-overlay">
        <button id="startButton" class="ui-button">ИГРАТЬ</button>
        <button id="debugButton" class="ui-button" style="display: none;">ДЕБАЖИТЬ</button>
        <div id="dialogueBubble"></div>
        <div id="cloudCounter">Облака: 0/10</div>
    </div>

    <div id="loadingScreen">
        <div class="loading-spinner"></div>
        <p>Loading 3D Scene...</p>
    </div>

    <!-- Import three.js from CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // Scene variables
        let scene, camera, renderer, clock;
        let sky, ground, cloudSystem, duck, pond;
        let isInitialized = false;
        let isRunning = false;

        // Scene management
        let currentScene = null;
        const scenes = {};

        // Game state variables
        let dialogueVisible = false;
        let dialogueBubbleElement;
        let cloudCounterElement;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let hoveredCloud = null;
        let hoveredPond = false;
        let isDebugMode = false;
        let debugTimeouts = [];

        // Scene setup functions
        // Setup the start scene (Scene 0)
        async function SetupScene0() {
            console.log("Setting up Scene 0 - Start Scene");

            // Initialize scene state
            currentScene.state = {
                isStarted: false
            };

            // Create scene if not exists
            if (!scene) {
                // Create scene
                scene = new THREE.Scene();

                // Create renderer
                renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('gameCanvas'),
                    antialias: true
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.shadowMap.enabled = true;

                // Create camera
                camera = createCamera();

                // Create clock for timing
                clock = new THREE.Clock();

                // Create sky
                sky = createSky();
                scene.add(sky);

                // Create ground
                ground = createGround();
                scene.add(ground);

                // Create cloud system
                cloudSystem = createCloudSystem(50);
                scene.add(cloudSystem);

                // Add ambient light
                const ambientLight = new THREE.AmbientLight();
                scene.add(ambientLight);

                // Add directional light (sun)
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 200, 100);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 1024;
                directionalLight.shadow.mapSize.height = 1024;

                // Configure shadow camera for better shadows
                directionalLight.shadow.camera.near = 10;
                directionalLight.shadow.camera.far = 500;
                directionalLight.shadow.camera.left = -150;
                directionalLight.shadow.camera.right = 150;
                directionalLight.shadow.camera.top = 150;
                directionalLight.shadow.camera.bottom = -150;

                // Adjust shadow bias to prevent shadow acne
                directionalLight.shadow.bias = -0.001;

                scene.add(directionalLight);

                // Load duck model
                try {
                    duck = await loadDuckModel();
                    duck.scale.set(6, 6, 6);
                    duck.position.set(0, -1, 0);
                    scene.add(duck);
                    console.log('Duck model loaded successfully');
                } catch (error) {
                    console.error('Failed to load duck model:', error);

                    console.log('Creating fallback duck model');

                    // Create a more duck-like fallback using primitive shapes
                    const duckGroup = new THREE.Group();

                    // Duck body (yellow sphere)
                    const bodyGeometry = new THREE.SphereGeometry(2, 32, 32);
                    const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    body.position.set(0, 3, 0);
                    body.castShadow = true;
                    duckGroup.add(body);

                    // Duck head (smaller yellow sphere)
                    const headGeometry = new THREE.SphereGeometry(1, 24, 24);
                    const headMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
                    const head = new THREE.Mesh(headGeometry, headMaterial);
                    head.position.set(0, 4.5, 1.5);
                    head.castShadow = true;
                    duckGroup.add(head);

                    // Duck beak (orange cone)
                    const beakGeometry = new THREE.ConeGeometry(0.5, 1.5, 8);
                    beakGeometry.rotateX(Math.PI / 2);
                    const beakMaterial = new THREE.MeshStandardMaterial({ color: 0xFF9900 });
                    const beak = new THREE.Mesh(beakGeometry, beakMaterial);
                    beak.position.set(0, 4.5, 3);
                    beak.castShadow = true;
                    duckGroup.add(beak);

                    duck = duckGroup;
                    scene.add(duck);
                }
            }

            // Setup start button
            const startButton = document.getElementById('startButton');
            startButton.style.display = 'block';

            // Setup debug button
            const debugButton = document.getElementById('debugButton');
            debugButton.style.display = 'block';

            // Setup start button click handler
            startButton.onclick = () => {
                // Hide the start button after clicking
                startButton.style.display = 'none';
                debugButton.style.display = 'none';

                // Update scene state
                currentScene.state.isStarted = true;

                // Animate camera to scene 1 position
                const targetPosition = new THREE.Vector3(-25, 4, -35);
                const targetLookAt = new THREE.Vector3(0, 3, 0);

                animateCameraTo(targetPosition, targetLookAt, () => {
                    // Transition to Scene 1 after camera animation
                    transitionToScene(1);
                });
            };

            // Setup debug button click handler
            debugButton.onclick = () => {
                // Hide both buttons after clicking
                startButton.style.display = 'none';
                debugButton.style.display = 'none';

                // Enable debug mode
                isDebugMode = true;

                // Update scene state
                currentScene.state.isStarted = true;

                // Start debug sequence
                startDebugSequence();
            };

            // Clear clickable objects array
            currentScene.clickableObjects = [];
        }

        // Cleanup for Scene 0
        function FinishScene0() {
            console.log("Cleaning up Scene 0");

            // Remove start button click handler
            const startButton = document.getElementById('startButton');
            startButton.onclick = null;

            // Remove debug button click handler
            const debugButton = document.getElementById('debugButton');
            debugButton.onclick = null;

            // Clear debug timeouts
            clearDebugTimeouts();
        }

        // Start debug sequence
        function startDebugSequence() {
            console.log("Starting debug sequence");

            // Clear any existing debug timeouts
            debugTimeouts.forEach(timeout => clearTimeout(timeout));
            debugTimeouts = [];

            // Animate camera to scene 1 position
            const targetPosition = new THREE.Vector3(-25, 4, -35);
            const targetLookAt = new THREE.Vector3(0, 3, 0);

            animateCameraTo(targetPosition, targetLookAt, () => {
                // Transition to Scene 1 after camera animation
                transitionToScene(1);
            });
        }

        // Debug scene progression
        function debugProgressScene(sceneId) {
            console.log(`Debug progressing from scene ${sceneId}`);

            // Universal auto-completion for all scenes
            debugTimeouts.push(setTimeout(() => {
                if (currentScene && currentScene.state) {
                    currentScene.state.isComplete = true;

                    // Auto-progress to next scene
                    const nextSceneId = sceneId + 1;
                    if (scenes[nextSceneId]) {
                        transitionToScene(nextSceneId);
                    } else {
                        console.log("Debug sequence complete");
                        isDebugMode = false;
                    }
                }
            }, 2000));
        }

        // Clear debug timeouts
        function clearDebugTimeouts() {
            debugTimeouts.forEach(timeout => clearTimeout(timeout));
            debugTimeouts = [];
        }

        // Setup Scene 1 - The Calm Pond (clicking clouds)
        function SetupScene1() {
            console.log("Setting up Scene 1 - The Calm Pond");

            // Initialize scene state
            currentScene.state = {
                clickedClouds: 0,
                requiredClouds: 10,
                isComplete: false
            };

            // Make clouds clickable and add handlers
            cloudSystem.children.forEach(cloud => {
                // Set up cloud as clickable
                cloud.userData.isClickable = true;

                // Add hover handler
                cloud.userData.handleHover = (isHovering) => {
                    if (isHovering) {
                        // Apply hover effect
                        const hoverMaterial = cloud.userData.originalMaterial.clone();
                        hoverMaterial.emissive = new THREE.Color(0x333333);
                        hoverMaterial.emissiveIntensity = 1.0;
                        hoverMaterial.color = new THREE.Color(0xDDDDDD);
                        cloud.material = hoverMaterial;
                    } else {
                        // Remove hover effect
                        cloud.material = cloud.userData.originalMaterial.clone();
                    }
                };

                // Add click handler
                cloud.userData.handleClick = () => {
                    // Remove cloud
                    cloudSystem.remove(cloud);

                    // Update scene state
                    currentScene.state.clickedClouds++;

                    // Update dialogue
                    showDialogue(`Нажимай на облака: ${currentScene.state.clickedClouds} из ${currentScene.state.requiredClouds}`);

                    // Check for scene completion
                    if (currentScene.state.clickedClouds >= currentScene.state.requiredClouds) {
                        currentScene.state.isComplete = true;

                        // Show completion dialogue
                        showDialogue("Теперь мне слишком жарко! Давай плескаться! Нажимай на пруд чтобы летели брызги.");

                        // Transition to Scene 2
                        transitionToScene(2);
                    }
                };
            });

            // Register clickable objects
            currentScene.clickableObjects = cloudSystem.children;

            // Show initial dialogue
            showDialogue("Привет! Как по мне, погода сегодня слишком облачная. Нажимай на облака чтобы они исчезли.");

            // Debug mode auto-progression
            if (isDebugMode) {
                debugProgressScene(1);
            }
        }

        // Cleanup for Scene 1
        function FinishScene1() {
            console.log("Cleaning up Scene 1");

            // Make clouds not clickable
            cloudSystem.children.forEach(cloud => {
                cloud.userData.isClickable = false;
            });

            // Reset hover states
            if (hoveredCloud) {
                hoveredCloud.material = hoveredCloud.userData.originalMaterial.clone();
                hoveredCloud = null;
            }

            // Clear debug timeouts
            clearDebugTimeouts();
        }

        // Setup Scene 2 - Splash in the water (clicking pond)
        function SetupScene2() {
            console.log("Setting up Scene 2 - Splash in the Water");

            // Initialize scene state
            currentScene.state = {
                splashCount: 0,
                requiredSplashes: 10,
                isComplete: false
            };

            // Make pond clickable
            pond.userData.isClickable = true;

            // Add hover handler
            pond.userData.handleHover = (isHovering) => {
                if (isHovering) {
                    // Apply hover effect
                    const hoverMaterial = pond.userData.originalMaterial.clone();
                    hoverMaterial.color = new THREE.Color(0x3A67B8); // Darker blue
                    pond.material = hoverMaterial;
                    hoveredPond = true;
                } else {
                    // Remove hover effect
                    pond.material = pond.userData.originalMaterial.clone();
                    hoveredPond = false;
                }
            };

            // Add click handler
            pond.userData.handleClick = (intersection) => {
                // Create splash effect
                createSplashEffect(intersection.point);

                // Update scene state
                currentScene.state.splashCount++;

                // Update dialogue
                showDialogue(`Давай плескаться: ${currentScene.state.splashCount} из ${currentScene.state.requiredSplashes}`);

                // Make clouds darker with each splash
                darkenClouds(currentScene.state.splashCount / currentScene.state.requiredSplashes);

                // Check for scene completion
                if (currentScene.state.splashCount >= currentScene.state.requiredSplashes) {
                    currentScene.state.isComplete = true;
                }
            };

            // Register clickable objects
            currentScene.clickableObjects = [pond];

            // Move camera to better view the pond
            const targetPosition = new THREE.Vector3(10, 4, -35);
            const targetLookAt = new THREE.Vector3(0, 3, 0);
            animateCameraTo(targetPosition, targetLookAt);

            // Show initial dialogue
            showDialogue("Теперь мне слишком жарко! Давай плескаться! Нажимай на пруд чтобы летели брызги.");

            // Debug mode auto-progression
            if (isDebugMode) {
                debugProgressScene(2);
            }
        }

        // Cleanup for Scene 2
        function FinishScene2() {
            console.log("Cleaning up Scene 2");

            // Make pond not clickable
            pond.userData.isClickable = false;
            currentScene.clickableObjects = [];

            // Reset hover state
            if (hoveredPond) {
                pond.material = pond.userData.originalMaterial.clone();
                hoveredPond = false;
            }

            // Clear debug timeouts
            clearDebugTimeouts();
        }

        // Setup Scene 3 - Up in the Clouds (placeholder for future implementation)
        function SetupScene3() {
            console.log("Setting up Scene 3 - Up in the Clouds");

            // Initialize scene state
            currentScene.state = {
                isComplete: false
            };

            // Show completion dialogue
            showDialogue("Ой ой");

            // Create and animate tornado
            createTornadoAnimation((tornado) => {
                animateDuckFlyingAway(tornado);
            });

            // Placeholder for future implementation
            showDialogue("Ой! Меня унесло ветром! Продолжение следует...");

            // Clear clickable objects

            // Debug mode auto-progression
            if (isDebugMode) {
                debugProgressScene(3);
            }
        }

        // Cleanup for Scene 3
        function FinishScene3() {
            console.log("Cleaning up Scene 3");
            // Placeholder for future implementation

            // Clear debug timeouts
            clearDebugTimeouts();
        }

        // Initialize the scene
        async function init() {
            // Initialize dialogue system
            initDialogueSystem();

            // Initialize scene manager
            initSceneManager();

            // Setup event listeners
            setupEventListeners();

            // Start with Scene 0
            await transitionToScene(0);

            // Hide loading screen
            document.getElementById('loadingScreen').style.display = 'none';

            // Start animation loop
            isInitialized = true;
            isRunning = true;
            animate();
        }

        // Initialize scene manager
        function initSceneManager() {
            // Register scenes
            scenes[0] = {
                id: 0,
                name: "Start Scene",
                setup: SetupScene0,
                cleanup: FinishScene0,
                clickableObjects: []
            };

            scenes[1] = {
                id: 1,
                name: "The Calm Pond",
                setup: SetupScene1,
                cleanup: FinishScene1,
                clickableObjects: []
            };

            scenes[2] = {
                id: 2,
                name: "Splash in the Water",
                setup: SetupScene2,
                cleanup: FinishScene2,
                clickableObjects: []
            };

            scenes[3] = {
                id: 3,
                name: "Up in the Clouds",
                setup: SetupScene3,
                cleanup: FinishScene3,
                clickableObjects: []
            };
        }

        // Scene transition function
        async function transitionToScene(sceneId) {
            console.log(`Transitioning to scene ${sceneId}`);

            // Clean up current scene if exists
            if (currentScene && currentScene.cleanup) {
                currentScene.cleanup();
            }

            // Set new current scene
            currentScene = scenes[sceneId];

            // Setup new scene
            if (currentScene && currentScene.setup) {
                await currentScene.setup();
            }
        }

        // Create sky with gradient
        function createSky() {
            // Create a large box geometry
            const geometry = new THREE.BoxGeometry(1000, 1000, 1000);

            // Create shader material for gradient
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    topColor: { value: new THREE.Color(0.5, 0.8, 1.0) },
                    bottomColor: { value: new THREE.Color(1.0, 1.0, 1.0) }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 topColor;
                    uniform vec3 bottomColor;
                    varying vec3 vWorldPosition;
                    void main() {
                        float h = normalize(vWorldPosition).y;
                        float t = max(0.0, min(1.0, (h + 1.0) / 2.0));
                        gl_FragColor = vec4(mix(bottomColor, topColor, t), 1.0);
                    }
                `,
                side: THREE.BackSide // Render the inside of the box
            });

            // Create mesh and add to scene
            const sky = new THREE.Mesh(geometry, material);
            return sky;
        }

        // Create ground plane with pond
        function createGround() {
            // Create a group to hold ground and pond
            const groundGroup = new THREE.Group();

            // Create a large circle geometry for the ground
            const groundRadius = 100;
            const segments = 50;
            const groundGeometry = new THREE.CircleGeometry(groundRadius, segments);

            // Rotate to be horizontal (XZ plane)
            groundGeometry.rotateX(-Math.PI / 2);

            // Create green material
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x6AE86F,
                roughness: 0.8,
                metalness: 0.2
            });

            // Create mesh for the ground
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.position.y = 0;
            ground.receiveShadow = true;
            groundGroup.add(ground);

            // Create a circle geometry for the pond
            const pondRadius = 15;
            const pondGeometry = new THREE.CircleGeometry(pondRadius, segments);

            // Rotate to be horizontal (XZ plane)
            pondGeometry.rotateX(-Math.PI / 2);

            // Create water material with blue color
            const pondMaterial = new THREE.MeshStandardMaterial({
                color: 0x4A87E8, // Blue water color
                roughness: 0.1,  // Smooth surface for water
                metalness: 0.3,  // Slight reflection
                transparent: true,
                opacity: 0.8     // Slightly transparent
            });

            // Create mesh for the pond
            pond = new THREE.Mesh(pondGeometry, pondMaterial);
            pond.position.y = 0.05; // Slightly above the ground to prevent z-fighting
            pond.receiveShadow = true;
            pond.name = 'pond';

            // Store original material for hover effect
            pond.userData.originalMaterial = pondMaterial.clone();
            pond.userData.isClickable = false; // Initially not clickable

            groundGroup.add(pond);

            return groundGroup;
        }

        // Create cloud system
        function createCloudSystem(count = 25) {
            // Create a group to hold all clouds
            const cloudSystem = new THREE.Group();

            // Create cloud geometry and material
            // Use a sphere geometry for better click detection
            const geometry = new THREE.SphereGeometry(2, 16, 16);
            const material = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                emissive: 0xAAAAAA,
                roughness: 0.5,
                metalness: 0,
                transparent: true,
                opacity: 0.7,
                depthWrite: true,
                alphaTest: 0.1
            });

            cloudSystem.userData.windSpeed = { x: 0, y: 0, z: 7 };
            cloudSystem.userData.r1 = 80;
            cloudSystem.userData.r2 = 110;
            cloudSystem.userData.h1 = 20;
            cloudSystem.userData.dh = 10;

            // Create individual clouds
            for (let i = 0; i < count; i++) {
                const cloud = new THREE.Mesh(geometry, material.clone());

                // Set name for debugging
                cloud.name = `cloud-${i}`;

                // Random position within a cylinder
                const radius = cloudSystem.userData.r2 * Math.sqrt(Math.random());
                const theta = Math.random() * Math.PI * 2;
                cloud.position.x = radius * Math.cos(theta);
                cloud.position.z = radius * Math.sin(theta);
                cloud.position.y = cloudSystem.userData.h1 + Math.random() * cloudSystem.userData.dh;

                // Random scale - make clouds larger for easier clicking
                const basicSize = 4 + Math.random() * 2;
                cloud.userData.dimensions = new THREE.Vector3(basicSize, basicSize * 0.7, basicSize);
                cloud.setScale = function(scale) {
                    this.scale.copy(this.userData.dimensions).multiplyScalar(scale);
                };
                cloud.setScale(1);

                // Store original position for resetting
                cloud.userData.originalPosition = cloud.position.clone();
                cloud.userData.outOfScene = false;
                cloud.userData.isClickable = false; // Initially not clickable
                cloud.userData.originalMaterial = cloud.material.clone();
                cloud.castShadow = true;

                cloudSystem.add(cloud);
            }

            // Add update function to cloud system
            cloudSystem.update = function(deltaTime) {
                const windSpeed = this.userData.windSpeed;

                // Update each cloud
                this.children.forEach(cloud => {
                    // Move cloud with wind
                    cloud.position.x += windSpeed.x * deltaTime;
                    cloud.position.y += windSpeed.y * deltaTime;
                    cloud.position.z += windSpeed.z * deltaTime;

                    // Check if cloud is out of bounds
                    const distanceFromCenter = Math.sqrt(
                        cloud.position.x * cloud.position.x +
                        cloud.position.z * cloud.position.z
                    );

                    const r1 = cloudSystem.userData.r1;
                    const r2 = cloudSystem.userData.r2;
                    if (distanceFromCenter >= r2) {
                        // Reset cloud position
                        const radius = r2;
                        const theta = Math.random() * Math.PI;
                        cloud.position.x = radius * Math.cos(theta);
                        cloud.position.z = -radius * Math.sin(theta);
                        cloud.position.y = cloudSystem.userData.h1 + Math.random() * cloudSystem.userData.dh;
                    } else if (distanceFromCenter >= r1) {
                        const scale = (r2-distanceFromCenter)/(r2-r1);
                        cloud.setScale(scale);
                    }
                });
            };

            cloudSystem.setClickable = function(value) {
                this.children.forEach(cloud => {
                    cloud.userData.isClickable = value;
                });
            }

            return cloudSystem;
        }

        // Load duck model
        function loadDuckModel() {
            return new Promise((resolve, reject) => {
                const loader = new GLTFLoader();

                // Check if the model file exists before attempting to load it
                fetch('models/Rubber_Duck.gltf')
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Model file not found (${response.status})`);
                        }

                        // If the file exists, load it with GLTFLoader
                        loader.load(
                            'models/Rubber_Duck.gltf',
                            (gltf) => {
                                const model = gltf.scene;

                                // Apply transformations
                                model.scale.set(8, 8, 8);
                                model.position.set(0, 0, 0);
                                model.rotation.y = Math.PI; // Rotate 180 degrees

                                // Apply materials if needed
                                model.traverse((child) => {
                                    if (child.isMesh) {
                                        child.castShadow = true;
                                        child.receiveShadow = true;
                                    }
                                });

                                resolve(model);
                            },
                            (xhr) => {
                                console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                            },
                            (error) => {
                                console.error('Error loading model:', error);
                                reject(error);
                            }
                        );
                    })
                    .catch(error => {
                        console.warn('Using fallback duck model:', error.message);
                        reject(error);
                    });
            });
        }

        // Create camera with swaying motion
        function createCamera() {
            const camera = new THREE.PerspectiveCamera(
                45, // FOV
                window.innerWidth / window.innerHeight, // Aspect ratio
                0.1, // Near clipping plane
                1000 // Far clipping plane
            );

            // Set initial position
            camera.position.set(-100, 50, -100);
            camera.lookAt(0, 1, 0);

            // Store original position for swaying
            camera.userData.basePosition = camera.position.clone();
            camera.userData.baseTarget = new THREE.Vector3(0, 1, 0);
            camera.userData.swayEnabled = true;
            camera.userData.swayAmplitude = 0.2;
            camera.userData.swaySpeed = 0.5;
            camera.userData.swayTime = 0;

            // Add update function to camera
            camera.update = function(deltaTime) {
                if (!this.userData.swayEnabled) return;

                this.userData.swayTime += deltaTime * this.userData.swaySpeed;

                // Calculate sway offsets
                const swayX = Math.sin(this.userData.swayTime) * this.userData.swayAmplitude;
                const swayY = Math.sin(this.userData.swayTime * 0.7) * this.userData.swayAmplitude * 0.5;
                const swayZ = Math.cos(this.userData.swayTime * 0.3) * this.userData.swayAmplitude * 0.3;

                // Apply sway to position
                this.position.copy(this.userData.basePosition);
                this.position.x += swayX;
                this.position.y += swayY;
                this.position.z += swayZ;

                // Apply slight sway to target
                const target = this.userData.baseTarget.clone();
                target.x += swayX * 0.2;
                target.y += swayY * 0.3;

                this.lookAt(target);
            };

            return camera;
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            if (!isRunning) return;

            const deltaTime = clock.getDelta();

            // Update camera sway
            camera.update(deltaTime);

            // Update cloud system
            cloudSystem.update(deltaTime);

            // Check for cloud hover
            checkCloudHover();

            // Check for pond hover
            checkPondHover();

            // Update dialogue position
            updateDialoguePosition();

            // Render scene
            renderer.render(scene, camera);
        }

        // Check for cloud hover
        function checkCloudHover() {
            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Calculate objects intersecting the picking ray
            const intersects = raycaster.intersectObjects(cloudSystem.children, false);

            // Reset previously hovered cloud
            if (hoveredCloud && (!intersects.length || intersects[0].object !== hoveredCloud)) {
                // Only reset if the cloud still exists and hasn't been clicked
                if (hoveredCloud.parent && hoveredCloud.userData.isClickable) {
                    hoveredCloud.material = hoveredCloud.userData.originalMaterial.clone();
                }
                hoveredCloud = null;
                document.body.style.cursor = 'default';
            }

            // Set new hovered cloud
            if (intersects.length > 0) {
                const cloud = intersects[0].object;
                if (cloud.userData.isClickable && cloud.visible) {
                    hoveredCloud = cloud;

                    // Apply hover effect (dark border and more visible)
                    const hoverMaterial = cloud.userData.originalMaterial.clone();
                    hoverMaterial.emissive = new THREE.Color(0x333333);
                    hoverMaterial.emissiveIntensity = 1.0;
                    hoverMaterial.color = new THREE.Color(0xDDDDDD);
                    cloud.material = hoverMaterial;

                    document.body.style.cursor = 'pointer';

                    // Debug info
                    console.log(`Hovering over cloud: ${cloud.name}`);
                }
            }
        }

        // Check for pond hover
        function checkPondHover() {
            // Only check if pond is clickable
            if (!pond || !pond.userData.isClickable) {
                return;
            }

            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Calculate objects intersecting the picking ray
            const intersects = raycaster.intersectObject(pond, false);

            // Reset hover state if not hovering
            if (hoveredPond && intersects.length === 0) {
                pond.material = pond.userData.originalMaterial.clone();
                hoveredPond = false;
                document.body.style.cursor = 'default';
            }

            // Set hover state if hovering
            if (intersects.length > 0) {
                hoveredPond = true;

                // Apply hover effect (darker blue)
                const hoverMaterial = pond.userData.originalMaterial.clone();
                hoverMaterial.color = new THREE.Color(0x3A67B8); // Darker blue
                pond.material = hoverMaterial;

                document.body.style.cursor = 'pointer';
            }
        }

        // Setup event listeners
        function setupEventListeners() {
            // Window resize
            window.addEventListener('resize', onWindowResize);

            // Mouse move for hover effect
            window.addEventListener('mousemove', onMouseMove);

            // Mouse click for interaction
            window.addEventListener('click', onMouseClick);
        }

        // Handle mouse move for hover effects
        function onMouseMove(event) {
            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Only process if the game is running
            if (!isRunning || !currentScene) return;

            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Get clickable objects from current scene
            const clickableObjects = currentScene.clickableObjects || [];

            // Find intersections with clickable objects
            const intersects = raycaster.intersectObjects(clickableObjects, false);

            // Reset hover states for all objects
            clickableObjects.forEach(obj => {
                if (obj.userData.isHovered && typeof obj.userData.handleHover === 'function') {
                    obj.userData.handleHover(false);
                    obj.userData.isHovered = false;
                }
            });

            // Set hover state for intersected object
            if (intersects.length > 0) {
                const object = intersects[0].object;
                if (object.userData.isClickable && object.visible) {
                    object.userData.isHovered = true;
                    if (typeof object.userData.handleHover === 'function') {
                        object.userData.handleHover(true);
                    }
                    document.body.style.cursor = 'pointer';
                }
            } else {
                document.body.style.cursor = 'default';
            }
        }

        // Handle mouse click
        function onMouseClick(event) {
            // Only process clicks if the game is running
            if (!isRunning || !currentScene) return;

            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Get clickable objects from current scene
            const clickableObjects = currentScene.clickableObjects || [];

            // Find intersections with clickable objects
            const intersects = raycaster.intersectObjects(clickableObjects, false);

            // Handle first intersection
            if (intersects.length > 0) {
                const object = intersects[0].object;
                if (object.userData.isClickable && object.visible) {
                    // Call the object's click handler
                    if (typeof object.userData.handleClick === 'function') {
                        object.userData.handleClick(intersects[0]);
                    }
                }
            }
        }

        // Initialize dialogue system
        function initDialogueSystem() {
            dialogueBubbleElement = document.getElementById('dialogueBubble');
            cloudCounterElement = document.getElementById('cloudCounter');
        }

        // Show dialogue
        function showDialogue(text) {
            dialogueBubbleElement.textContent = text;
            dialogueBubbleElement.style.opacity = '1';
            dialogueVisible = true;

            // Position the dialogue bubble above the duck
            updateDialoguePosition();
        }

        // Hide dialogue
        function hideDialogue() {
            dialogueBubbleElement.style.opacity = '0';
            dialogueVisible = false;
        }

        // Update dialogue position
        function updateDialoguePosition() {
            if (!dialogueVisible || !duck) return;

            // Get duck position in screen space
            const duckPosition = new THREE.Vector3(0, 6.5, 0); // Approximate position above duck
            const screenPosition = duckPosition.clone();
            screenPosition.project(camera);

            // Convert to CSS coordinates
            const x = (screenPosition.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-(screenPosition.y * 0.5) + 0.5) * window.innerHeight;

            // Update dialogue bubble position
            dialogueBubbleElement.style.left = `${x}px`;
            dialogueBubbleElement.style.top = `${y}px`;
        }

        // Update cloud counter
        function updateCloudCounter() {
            // Update the dialogue bubble text instead of a separate counter
            if (dialogueVisible && currentScene && currentScene.state) {
                showDialogue(`Нажимай на облака: ${currentScene.state.clickedClouds} из ${currentScene.state.requiredClouds}`);
            }
        }

        // Handle window resize
        function onWindowResize() {
            // Update camera aspect ratio
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            // Update renderer size
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
        }

        // Create splash effect
        function createSplashEffect(position) {
            // Create a group for the splash effect
            const splashGroup = new THREE.Group();
            splashGroup.position.copy(position);

            // Create particles for the splash
            const particleCount = 20;
            const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const particleMaterial = new THREE.MeshBasicMaterial({
                color: 0x4A87E8,
                transparent: true,
                opacity: 0.8
            });

            // Create particles with random velocities
            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Mesh(particleGeometry, particleMaterial.clone());

                // Random initial position slightly above the pond
                particle.position.set(
                    (Math.random() - 0.5) * 0.5,
                    0.1,
                    (Math.random() - 0.5) * 0.5
                );

                // Random velocity
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 2;
                particle.userData.velocity = new THREE.Vector3(
                    Math.cos(angle) * speed,
                    2 + Math.random() * 3, // Upward velocity
                    Math.sin(angle) * speed
                );

                // Random scale
                const scale = 0.3 + Math.random() * 0.7;
                particle.scale.set(scale, scale, scale);

                splashGroup.add(particle);
            }

            // Add the splash group to the scene
            scene.add(splashGroup);

            // Animation duration
            const duration = 1.0; // seconds
            const startTime = performance.now();

            // Animation function
            function animateSplash() {
                const currentTime = performance.now();
                const elapsed = (currentTime - startTime) / 1000; // Convert to seconds

                if (elapsed < duration) {
                    // Update each particle
                    splashGroup.children.forEach(particle => {
                        // Apply velocity
                        particle.position.x += particle.userData.velocity.x * 0.016; // Assuming ~60fps
                        particle.position.y += particle.userData.velocity.y * 0.016;
                        particle.position.z += particle.userData.velocity.z * 0.016;

                        // Apply gravity
                        particle.userData.velocity.y -= 9.8 * 0.016;

                        // Fade out
                        if (particle.material.opacity > 0) {
                            particle.material.opacity = 0.8 * (1 - elapsed / duration);
                        }
                    });

                    requestAnimationFrame(animateSplash);
                } else {
                    // Remove splash group when animation is complete
                    scene.remove(splashGroup);
                    splashGroup.children.forEach(particle => {
                        particle.geometry.dispose();
                        particle.material.dispose();
                    });
                }
            }

            // Start animation
            requestAnimationFrame(animateSplash);
        }

        // Darken clouds based on splash count
        function darkenClouds(intensity) {
            // Intensity should be between 0 and 1
            intensity = Math.min(Math.max(intensity, 0), 1);

            // Apply darkening to all clouds
            cloudSystem.children.forEach(cloud => {
                // Get original color and darken it
                const originalColor = cloud.userData.originalMaterial.color.clone();
                const darkenedColor = new THREE.Color(
                    originalColor.r * (1 - intensity * 0.5),
                    originalColor.g * (1 - intensity * 0.5),
                    originalColor.b * (1 - intensity * 0.5)
                );

                // Apply darkened color if the cloud is not being hovered
                if (cloud !== hoveredCloud) {
                    cloud.material.color.copy(darkenedColor);
                }
            });
        }

        // Animate camera to game position
        function animateCameraTo(targetPosition, targetLookAt, onComplete) {
            // Disable camera sway during animation
            camera.userData.swayEnabled = false;

            // Store original values
            const startPosition = camera.position.clone();
            const startTarget = camera.userData.baseTarget.clone();

            // Animation duration
            const duration = 1.0; // Reduce to 1 second for faster animation
            const startTime = performance.now();

            // Animation function
            function animateCamera() {
                const currentTime = performance.now();
                const elapsed = (currentTime - startTime) / 1000; // Convert to seconds
                const t = Math.min(elapsed / duration, 1);

                // Cubic easing
                const ease = t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;

                // Interpolate position
                camera.position.lerpVectors(startPosition, targetPosition, ease);

                // Interpolate target
                const currentTarget = new THREE.Vector3();
                currentTarget.lerpVectors(startTarget, targetLookAt, ease);
                camera.lookAt(currentTarget);

                // Update base values for when sway is re-enabled
                camera.userData.basePosition.copy(camera.position);
                camera.userData.baseTarget.copy(currentTarget);

                // Continue animation if not complete
                if (t < 1) {
                    requestAnimationFrame(animateCamera);
                } else {
                    console.log('Camera animation complete');
                    // Re-enable camera sway if desired
                    // camera.userData.swayEnabled = true;

                    // Call completion callback if provided
                    if (typeof onComplete === 'function') {
                        onComplete();
                    }
                }
            }

            // Start animation
            requestAnimationFrame(animateCamera);
        }

        // Create and animate tornado
        function createTornadoAnimation(completionHandler) {
            const tornado = createTornado();
            scene.add(tornado);

            const config = {
                startPos: new THREE.Vector3(-50, 0, 50),
                endPos: new THREE.Vector3(0, 0, 0),
                duration: 2.0
            };

            tornado.position.copy(config.startPos);

            const startTime = performance.now();

            function animateTornado() {
                const elapsed = (performance.now() - startTime) / 1000;
                const progress = Math.min(elapsed / config.duration, 1);
                const ease = progress < 0.5 ? 4 * progress ** 3 : 1 - ((-2 * progress + 2) ** 3) / 2;

                tornado.position.lerpVectors(config.startPos, config.endPos, ease);
                tornado.rotation.y += 0.1;
                tornado.update(0.016);

                if (progress < 1) {
                    requestAnimationFrame(animateTornado);
                } else {
                    if (completionHandler) completionHandler(tornado);
                }
            }

            requestAnimationFrame(animateTornado);
        }

        // Create tornado mesh with shader
        function createTornado() {
            // Create a cone geometry for the tornado
            const geometry = new THREE.ConeGeometry(5, 20, 32, 1, true);

            // Create shader material for tornado
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0.0 },
                    color1: { value: new THREE.Color(0x666666) }, // Dark gray
                    color2: { value: new THREE.Color(0x999999) }  // Light gray
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vPosition;

                    void main() {
                        vUv = uv;
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 color1;
                    uniform vec3 color2;
                    varying vec2 vUv;
                    varying vec3 vPosition;

                    void main() {
                        // Create swirling pattern
                        float swirl = sin(vUv.y * 20.0 + time * 5.0) * 0.5 + 0.5;

                        // Mix colors based on swirl pattern
                        vec3 color = mix(color1, color2, swirl);

                        // Add transparency gradient from bottom to top
                        float alpha = mix(0.9, 0.3, vUv.y);

                        gl_FragColor = vec4(color, alpha);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide
            });

            // Create mesh
            const tornado = new THREE.Mesh(geometry, material);

            // Rotate to make it upside down
            tornado.rotation.x = Math.PI;

            // Add update function
            tornado.update = function(deltaTime) {
                this.material.uniforms.time.value += deltaTime;
            };

            return tornado;
        }

        // Animate duck flying away with camera
        function animateDuckFlyingAway(tornado) {
            const config = {
                duration: 3.0,
                duckStart: duck.position.clone(),
                duckEnd: new THREE.Vector3(0, 30, 0),
                cameraStart: camera.position.clone(),
                cameraEnd: new THREE.Vector3(-30, 35, -30),
                targetStart: camera.userData.baseTarget.clone(),
                targetEnd: new THREE.Vector3(0, 30, 0)
            };

            camera.userData.swayEnabled = false;
            const startTime = performance.now();

            function animateFlyAway() {
                const elapsed = (performance.now() - startTime) / 1000;
                const progress = Math.min(elapsed / config.duration, 1);
                const ease = progress < 0.5 ? 4 * progress ** 3 : 1 - ((-2 * progress + 2) ** 3) / 2;

                duck.position.lerpVectors(config.duckStart, config.duckEnd, ease);
                camera.position.lerpVectors(config.cameraStart, config.cameraEnd, ease);

                const currentTarget = new THREE.Vector3();
                currentTarget.lerpVectors(config.targetStart, config.targetEnd, ease);
                camera.lookAt(currentTarget);

                camera.userData.basePosition.copy(camera.position);
                camera.userData.baseTarget.copy(currentTarget);

                if (tornado) {
                    tornado.position.set(duck.position.x, duck.position.y - 10, duck.position.z);
                    tornado.update(0.016);
                }

                if (progress < 1) {
                    requestAnimationFrame(animateFlyAway);
                } else {
                    console.log('Duck has flown away!');
                    showDialogue("Ой! Меня унесло ветром! Продолжение следует...");

                    setTimeout(() => {
                        if (tornado?.parent) {
                            scene.remove(tornado);
                            tornado.material.dispose();
                            tornado.geometry.dispose();
                        }
                    }, 2000);
                }
            }

            requestAnimationFrame(animateFlyAway);
        }

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
