<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Duck Scene</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #5CCCFF; /* Light blue to match sky */
            font-family: Arial, sans-serif;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .ui-button {
            pointer-events: auto;
            position: absolute;
            padding: 15px 30px;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #333;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            color: #333;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
        }

        .ui-button:hover {
            background: rgba(255, 255, 255, 1);
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        #startButton {
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
        }

        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            color: #fff;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid #333;
            border-top: 3px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .ui-button {
                padding: 12px 24px;
                font-size: 16px;
            }

            #startButton {
                bottom: 30px;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="ui-overlay">
        <button id="startButton" class="ui-button">START</button>
    </div>

    <div id="loadingScreen">
        <div class="loading-spinner"></div>
        <p>Loading 3D Scene...</p>
    </div>

    <!-- Import three.js from CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // Scene variables
        let scene, camera, renderer, clock;
        let sky, ground, cloudSystem, duck;
        let isInitialized = false;
        let isRunning = false;

        // Initialize the scene
        async function init() {
            // Create scene
            scene = new THREE.Scene();

            // Create renderer
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('gameCanvas'),
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;

            // Create camera
            camera = createCamera();

            // Create clock for timing
            clock = new THREE.Clock();

            // Create sky
            sky = createSky();
            scene.add(sky);

            // Create ground
            ground = createGround();
            scene.add(ground);

            // Create cloud system
            cloudSystem = createCloudSystem(80); // 80 clouds as in original
            scene.add(cloudSystem);

            // Add ambient light
            const ambientLight = new THREE.AmbientLight();
            scene.add(ambientLight);

            // Add directional light (sun)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 200, 100);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            scene.add(directionalLight);

            // Load duck model
            try {
                // throw "Aaa"
                duck = await loadDuckModel();
                duck.scale.set(6, 6, 6);
                scene.add(duck);
                console.log('Duck model loaded successfully');
            } catch (error) {
                console.error('Failed to load duck model:', error);

                console.log('Creating fallback duck model');

                // Create a more duck-like fallback using primitive shapes
                const duckGroup = new THREE.Group();

                // Duck body (yellow sphere)
                const bodyGeometry = new THREE.SphereGeometry(2, 32, 32);
                const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.set(0, 3, 0);
                body.castShadow = true;
                duckGroup.add(body);

                // Duck head (smaller yellow sphere)
                const headGeometry = new THREE.SphereGeometry(1, 24, 24);
                const headMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.set(0, 4.5, 1.5);
                head.castShadow = true;
                duckGroup.add(head);

                // Duck beak (orange cone)
                const beakGeometry = new THREE.ConeGeometry(0.5, 1.5, 8);
                beakGeometry.rotateX(Math.PI / 2);
                const beakMaterial = new THREE.MeshStandardMaterial({ color: 0xFF9900 });
                const beak = new THREE.Mesh(beakGeometry, beakMaterial);
                beak.position.set(0, 4.5, 3);
                beak.castShadow = true;
                duckGroup.add(beak);

                duck = duckGroup;
                scene.add(duck);
            }

            // Setup event listeners
            setupEventListeners();

            // Hide loading screen
            document.getElementById('loadingScreen').style.display = 'none';

            // Start animation loop
            isInitialized = true;
            isRunning = true;
            animate();
        }

        // Create sky with gradient
        function createSky() {
            // Create a large box geometry
            const geometry = new THREE.BoxGeometry(1000, 1000, 1000);

            // Create shader material for gradient
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    topColor: { value: new THREE.Color(0.5, 0.8, 1.0) },
                    bottomColor: { value: new THREE.Color(1.0, 1.0, 1.0) }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 topColor;
                    uniform vec3 bottomColor;
                    varying vec3 vWorldPosition;
                    void main() {
                        float h = normalize(vWorldPosition).y;
                        float t = max(0.0, min(1.0, (h + 1.0) / 2.0));
                        gl_FragColor = vec4(mix(bottomColor, topColor, t), 1.0);
                    }
                `,
                side: THREE.BackSide // Render the inside of the box
            });

            // Create mesh and add to scene
            const sky = new THREE.Mesh(geometry, material);
            return sky;
        }

        // Create ground plane
        function createGround() {
            // Create a large circle geometry
            const radius = 100;
            const segments = 50;
            const geometry = new THREE.CircleGeometry(radius, segments);

            // Rotate to be horizontal (XZ plane)
            geometry.rotateX(-Math.PI / 2);

            // Create green material
            const material = new THREE.MeshStandardMaterial({
                color: 0x6AE86F,
                roughness: 0.8,
                metalness: 0.2
            });

            // Create mesh and add to scene
            const ground = new THREE.Mesh(geometry, material);
            ground.position.y = 0; // Slightly below origin
            ground.receiveShadow = true;

            return ground;
        }

        // Create cloud system
        function createCloudSystem(count = 25) {
            // Create a group to hold all clouds
            const cloudSystem = new THREE.Group();

            // Create cloud geometry and material
            const geometry = new THREE.BoxGeometry(2, 1, 3);
            const material = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                roughness: 0.0,
                metalness: 0.0,
                transparent: true,
                opacity: 0.8
            });

            // Create individual clouds
            for (let i = 0; i < count; i++) {
                const cloud = new THREE.Mesh(geometry, material.clone());

                // Random position within a cylinder
                const radius = 100 * Math.sqrt(Math.random());
                const theta = Math.random() * Math.PI * 2;
                cloud.position.x = radius * Math.cos(theta);
                cloud.position.z = radius * Math.sin(theta);
                cloud.position.y = 20 + Math.random() * 10;

                // Random scale
                const scale = 3 + Math.random();
                cloud.scale.set(scale, scale * 0.7, scale);

                // Random rotation
                cloud.rotation.y = Math.random() * Math.PI * 2;

                // Store original position for resetting
                cloud.userData.originalPosition = cloud.position.clone();
                cloud.userData.outOfScene = false;

                cloudSystem.add(cloud);
            }

            // Add update function to cloud system
            cloudSystem.update = function(deltaTime) {
                const windSpeed = { x: 0, y: 0, z: 7 }; // Matches original

                // Update each cloud
                this.children.forEach(cloud => {
                    // Move cloud with wind
                    cloud.position.x += windSpeed.x * deltaTime;
                    cloud.position.y += windSpeed.y * deltaTime;
                    cloud.position.z += windSpeed.z * deltaTime;

                    // Check if cloud is out of bounds
                    const distanceFromCenter = Math.sqrt(
                        cloud.position.x * cloud.position.x +
                        cloud.position.z * cloud.position.z
                    );

                    if (distanceFromCenter >= 100) {
                        // Reset cloud position
                        const radius = 100;
                        const theta = Math.random() * Math.PI * 2;
                        cloud.position.x = radius * Math.cos(theta);
                        cloud.position.z = radius * Math.sin(theta);
                        cloud.position.y = 20 + Math.random() * 10;
                    }
                });
            };

            return cloudSystem;
        }

        // Load duck model
        function loadDuckModel() {
            return new Promise((resolve, reject) => {
                const loader = new GLTFLoader();

                // Check if the model file exists before attempting to load it
                fetch('models/Rubber_Duck.gltf')
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Model file not found (${response.status})`);
                        }

                        // If the file exists, load it with GLTFLoader
                        loader.load(
                            'models/Rubber_Duck.gltf',
                            (gltf) => {
                                const model = gltf.scene;

                                // Apply transformations
                                model.scale.set(8, 8, 8);
                                model.position.set(0, 0, 0);
                                model.rotation.y = Math.PI; // Rotate 180 degrees

                                // Apply materials if needed
                                model.traverse((child) => {
                                    if (child.isMesh) {
                                        child.castShadow = true;
                                        child.receiveShadow = true;
                                    }
                                });

                                resolve(model);
                            },
                            (xhr) => {
                                console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                            },
                            (error) => {
                                console.error('Error loading model:', error);
                                reject(error);
                            }
                        );
                    })
                    .catch(error => {
                        console.warn('Using fallback duck model:', error.message);
                        reject(error);
                    });
            });
        }

        // Create camera with swaying motion
        function createCamera() {
            const camera = new THREE.PerspectiveCamera(
                45, // FOV
                window.innerWidth / window.innerHeight, // Aspect ratio
                0.1, // Near clipping plane
                1000 // Far clipping plane
            );

            // Set initial position
            camera.position.set(-90, 50, -110);
            camera.lookAt(0, 1, 0);

            // Store original position for swaying
            camera.userData.basePosition = camera.position.clone();
            camera.userData.baseTarget = new THREE.Vector3(0, 1, 0);
            camera.userData.swayEnabled = true;
            camera.userData.swayAmplitude = 0.02;
            camera.userData.swaySpeed = 0.5;
            camera.userData.swayTime = 0;

            // Add update function to camera
            camera.update = function(deltaTime) {
                if (!this.userData.swayEnabled) return;

                this.userData.swayTime += deltaTime * this.userData.swaySpeed;

                // Calculate sway offsets
                const swayX = Math.sin(this.userData.swayTime) * this.userData.swayAmplitude;
                const swayY = Math.sin(this.userData.swayTime * 0.7) * this.userData.swayAmplitude * 0.5;
                const swayZ = Math.cos(this.userData.swayTime * 0.3) * this.userData.swayAmplitude * 0.3;

                // Apply sway to position
                this.position.copy(this.userData.basePosition);
                this.position.x += swayX;
                this.position.y += swayY;
                this.position.z += swayZ;

                // Apply slight sway to target
                const target = this.userData.baseTarget.clone();
                target.x += swayX * 0.2;
                target.y += swayY * 0.3;

                this.lookAt(target);
            };

            return camera;
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            if (!isRunning) return;

            const deltaTime = clock.getDelta();

            // Update camera sway
            camera.update(deltaTime);

            // Update cloud system
            cloudSystem.update(deltaTime);

            // Render scene
            renderer.render(scene, camera);
        }

        // Setup event listeners
        function setupEventListeners() {
            // START button click
            const startButton = document.getElementById('startButton');
            startButton.addEventListener('click', () => {
                console.log('Start button clicked - initiating camera animation');
                animateCameraToGamePosition();
            });

            // Window resize
            window.addEventListener('resize', onWindowResize);
        }

        // Handle window resize
        function onWindowResize() {
            // Update camera aspect ratio
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            // Update renderer size
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
        }

        // Animate camera to game position
        function animateCameraToGamePosition() {
            // Disable camera sway during animation
            camera.userData.swayEnabled = false;

            // Target position and look-at
            const targetPosition = new THREE.Vector3(-45, 10, -55);
            const targetLookAt = new THREE.Vector3(0, 0, 0);

            // Store original values
            const startPosition = camera.position.clone();
            const startTarget = camera.userData.baseTarget.clone();

            // Animation duration
            const duration = 1.0; // Reduce to 1 second for faster animation
            const startTime = performance.now();

            // Animation function
            function animateCamera() {
                const currentTime = performance.now();
                const elapsed = (currentTime - startTime) / 1000; // Convert to seconds
                const t = Math.min(elapsed / duration, 1);

                // Cubic easing
                const ease = t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;

                // Interpolate position
                camera.position.lerpVectors(startPosition, targetPosition, ease);

                // Interpolate target
                const currentTarget = new THREE.Vector3();
                currentTarget.lerpVectors(startTarget, targetLookAt, ease);
                camera.lookAt(currentTarget);

                // Update base values for when sway is re-enabled
                camera.userData.basePosition.copy(camera.position);
                camera.userData.baseTarget.copy(currentTarget);

                // Continue animation if not complete
                if (t < 1) {
                    requestAnimationFrame(animateCamera);
                } else {
                    console.log('Camera animation complete');
                    // Re-enable camera sway if desired
                    // camera.userData.swayEnabled = true;
                }
            }

            // Start animation
            requestAnimationFrame(animateCamera);
        }

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
