<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Duck Scene</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #5CCCFF; /* Light blue to match sky */
            font-family: Arial, sans-serif;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .ui-button {
            pointer-events: auto;
            position: absolute;
            padding: 15px 30px;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #333;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            color: #333;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
        }

        .ui-button:hover {
            background: rgba(255, 255, 255, 1);
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        #startButton {
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
        }

        /* Dialogue bubble styles */
        #dialogueBubble {
            pointer-events: none;
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #333;
            border-radius: 15px;
            padding: 15px;
            max-width: 300px;
            font-size: 16px;
            color: #333;
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s ease;
            z-index: 150;
            transform: translate(-50%, -100%);
            margin-top: -20px;
        }

        #dialogueBubble:after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            width: 0;
            height: 0;
            border: 10px solid transparent;
            border-top-color: #333;
            border-bottom: 0;
            margin-left: -10px;
        }

        /* Cloud counter styles */
        #cloudCounter {
            display: none; /* Hide the cloud counter since we're using the dialogue bubble instead */
            pointer-events: none;
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.8);
            border: 2px solid #333;
            border-radius: 8px;
            padding: 10px 15px;
            font-size: 16px;
            font-weight: bold;
            color: #333;
            z-index: 150;
        }

        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            color: #fff;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid #333;
            border-top: 3px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .ui-button {
                padding: 12px 24px;
                font-size: 16px;
            }

            #startButton {
                bottom: 30px;
            }

            #dialogueBubble {
                max-width: 250px;
                font-size: 14px;
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="ui-overlay">
        <button id="startButton" class="ui-button">ИГРАТЬ</button>
        <div id="dialogueBubble"></div>
        <div id="cloudCounter">Облака: 0/10</div>
    </div>

    <div id="loadingScreen">
        <div class="loading-spinner"></div>
        <p>Loading 3D Scene...</p>
    </div>

    <!-- Import three.js from CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // Scene variables
        let scene, camera, renderer, clock;
        let sky, ground, cloudSystem, duck;
        let isInitialized = false;
        let isRunning = false;

        // Game state variables
        let clickedClouds = 0;
        let dialogueVisible = false;
        let dialogueBubbleElement;
        let cloudCounterElement;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let hoveredCloud = null;

        // Initialize the scene
        async function init() {
            // Create scene
            scene = new THREE.Scene();

            // Create renderer
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('gameCanvas'),
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;

            // Create camera
            camera = createCamera();

            // Create clock for timing
            clock = new THREE.Clock();

            // Create sky
            sky = createSky();
            scene.add(sky);

            // Create ground
            ground = createGround();
            scene.add(ground);

            // Create cloud system
            cloudSystem = createCloudSystem(50);
            scene.add(cloudSystem);

            // Add ambient light
            const ambientLight = new THREE.AmbientLight();
            scene.add(ambientLight);

            // Add directional light (sun)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 200, 100);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;

            // Configure shadow camera for better shadows
            directionalLight.shadow.camera.near = 10;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -150;
            directionalLight.shadow.camera.right = 150;
            directionalLight.shadow.camera.top = 150;
            directionalLight.shadow.camera.bottom = -150;

            // Adjust shadow bias to prevent shadow acne
            directionalLight.shadow.bias = -0.001;

            scene.add(directionalLight);

            // Load duck model
            try {
                // throw "Aaa"
                duck = await loadDuckModel();
                duck.scale.set(6, 6, 6);
                duck.position.set(0, -1, 0);
                scene.add(duck);
                console.log('Duck model loaded successfully');
            } catch (error) {
                console.error('Failed to load duck model:', error);

                console.log('Creating fallback duck model');

                // Create a more duck-like fallback using primitive shapes
                const duckGroup = new THREE.Group();

                // Duck body (yellow sphere)
                const bodyGeometry = new THREE.SphereGeometry(2, 32, 32);
                const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.set(0, 3, 0);
                body.castShadow = true;
                duckGroup.add(body);

                // Duck head (smaller yellow sphere)
                const headGeometry = new THREE.SphereGeometry(1, 24, 24);
                const headMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.set(0, 4.5, 1.5);
                head.castShadow = true;
                duckGroup.add(head);

                // Duck beak (orange cone)
                const beakGeometry = new THREE.ConeGeometry(0.5, 1.5, 8);
                beakGeometry.rotateX(Math.PI / 2);
                const beakMaterial = new THREE.MeshStandardMaterial({ color: 0xFF9900 });
                const beak = new THREE.Mesh(beakGeometry, beakMaterial);
                beak.position.set(0, 4.5, 3);
                beak.castShadow = true;
                duckGroup.add(beak);

                duck = duckGroup;
                scene.add(duck);
            }

            // Setup event listeners
            setupEventListeners();

            // Initialize dialogue system
            initDialogueSystem();

            // Hide loading screen
            document.getElementById('loadingScreen').style.display = 'none';

            // Start animation loop
            isInitialized = true;
            isRunning = true;
            animate();
        }

        // Create sky with gradient
        function createSky() {
            // Create a large box geometry
            const geometry = new THREE.BoxGeometry(1000, 1000, 1000);

            // Create shader material for gradient
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    topColor: { value: new THREE.Color(0.5, 0.8, 1.0) },
                    bottomColor: { value: new THREE.Color(1.0, 1.0, 1.0) }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 topColor;
                    uniform vec3 bottomColor;
                    varying vec3 vWorldPosition;
                    void main() {
                        float h = normalize(vWorldPosition).y;
                        float t = max(0.0, min(1.0, (h + 1.0) / 2.0));
                        gl_FragColor = vec4(mix(bottomColor, topColor, t), 1.0);
                    }
                `,
                side: THREE.BackSide // Render the inside of the box
            });

            // Create mesh and add to scene
            const sky = new THREE.Mesh(geometry, material);
            return sky;
        }

        // Create ground plane with pond
        function createGround() {
            // Create a group to hold ground and pond
            const groundGroup = new THREE.Group();

            // Create a large circle geometry for the ground
            const groundRadius = 100;
            const segments = 50;
            const groundGeometry = new THREE.CircleGeometry(groundRadius, segments);

            // Rotate to be horizontal (XZ plane)
            groundGeometry.rotateX(-Math.PI / 2);

            // Create green material
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x6AE86F,
                roughness: 0.8,
                metalness: 0.2
            });

            // Create mesh for the ground
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.position.y = 0;
            ground.receiveShadow = true;
            groundGroup.add(ground);

            // Create a circle geometry for the pond
            const pondRadius = 15;
            const pondGeometry = new THREE.CircleGeometry(pondRadius, segments);

            // Rotate to be horizontal (XZ plane)
            pondGeometry.rotateX(-Math.PI / 2);

            // Create water material with blue color
            const pondMaterial = new THREE.MeshStandardMaterial({
                color: 0x4A87E8, // Blue water color
                roughness: 0.1,  // Smooth surface for water
                metalness: 0.3,  // Slight reflection
                transparent: true,
                opacity: 0.8     // Slightly transparent
            });

            // Create mesh for the pond
            const pond = new THREE.Mesh(pondGeometry, pondMaterial);
            pond.position.y = 0.05; // Slightly above the ground to prevent z-fighting
            pond.receiveShadow = true;
            groundGroup.add(pond);

            return groundGroup;
        }

        // Create cloud system
        function createCloudSystem(count = 25) {
            // Create a group to hold all clouds
            const cloudSystem = new THREE.Group();

            // Create cloud geometry and material
            // Use a sphere geometry for better click detection
            const geometry = new THREE.SphereGeometry(2, 16, 16);
            const material = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                emissive: 0xAAAAAA,
                roughness: 0.5,
                metalness: 0,
                transparent: true,
                opacity: 0.7,
                depthWrite: true,
                alphaTest: 0.1
            });

            cloudSystem.userData.windSpeed = { x: 0, y: 0, z: 7 };
            cloudSystem.userData.r1 = 80;
            cloudSystem.userData.r2 = 110;
            cloudSystem.userData.h1 = 20;
            cloudSystem.userData.dh = 10;

            // Create individual clouds
            for (let i = 0; i < count; i++) {
                const cloud = new THREE.Mesh(geometry, material.clone());

                // Set name for debugging
                cloud.name = `cloud-${i}`;

                // Random position within a cylinder
                const radius = cloudSystem.userData.r2 * Math.sqrt(Math.random());
                const theta = Math.random() * Math.PI * 2;
                cloud.position.x = radius * Math.cos(theta);
                cloud.position.z = radius * Math.sin(theta);
                cloud.position.y = cloudSystem.userData.h1 + Math.random() * cloudSystem.userData.dh;

                // Random scale - make clouds larger for easier clicking
                const basicSize = 4 + Math.random() * 2;
                cloud.userData.dimensions = new THREE.Vector3(basicSize, basicSize * 0.7, basicSize);
                cloud.setScale = function(scale) {
                    this.scale.copy(this.userData.dimensions).multiplyScalar(scale);
                };
                cloud.setScale(1);

                // Store original position for resetting
                cloud.userData.originalPosition = cloud.position.clone();
                cloud.userData.outOfScene = false;
                cloud.userData.isClickable = false; // Initially not clickable
                cloud.userData.originalMaterial = cloud.material.clone();
                cloud.castShadow = true;

                cloudSystem.add(cloud);
            }

            // Add update function to cloud system
            cloudSystem.update = function(deltaTime) {
                const windSpeed = this.userData.windSpeed;

                // Update each cloud
                this.children.forEach(cloud => {
                    // Move cloud with wind
                    cloud.position.x += windSpeed.x * deltaTime;
                    cloud.position.y += windSpeed.y * deltaTime;
                    cloud.position.z += windSpeed.z * deltaTime;

                    // Check if cloud is out of bounds
                    const distanceFromCenter = Math.sqrt(
                        cloud.position.x * cloud.position.x +
                        cloud.position.z * cloud.position.z
                    );

                    const r1 = cloudSystem.userData.r1;
                    const r2 = cloudSystem.userData.r2;
                    if (distanceFromCenter >= r2) {
                        // Reset cloud position
                        const radius = r2;
                        const theta = Math.random() * Math.PI;
                        cloud.position.x = radius * Math.cos(theta);
                        cloud.position.z = -radius * Math.sin(theta);
                        cloud.position.y = cloudSystem.userData.h1 + Math.random() * cloudSystem.userData.dh;
                    } else if (distanceFromCenter >= r1) {
                        const scale = (r2-distanceFromCenter)/(r2-r1);
                        cloud.setScale(scale);
                    }
                });
            };

            cloudSystem.setClickable = function(value) {
                this.children.forEach(cloud => {
                    cloud.userData.isClickable = value;
                });
            }

            return cloudSystem;
        }

        // Load duck model
        function loadDuckModel() {
            return new Promise((resolve, reject) => {
                const loader = new GLTFLoader();

                // Check if the model file exists before attempting to load it
                fetch('models/Rubber_Duck.gltf')
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Model file not found (${response.status})`);
                        }

                        // If the file exists, load it with GLTFLoader
                        loader.load(
                            'models/Rubber_Duck.gltf',
                            (gltf) => {
                                const model = gltf.scene;

                                // Apply transformations
                                model.scale.set(8, 8, 8);
                                model.position.set(0, 0, 0);
                                model.rotation.y = Math.PI; // Rotate 180 degrees

                                // Apply materials if needed
                                model.traverse((child) => {
                                    if (child.isMesh) {
                                        child.castShadow = true;
                                        child.receiveShadow = true;
                                    }
                                });

                                resolve(model);
                            },
                            (xhr) => {
                                console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                            },
                            (error) => {
                                console.error('Error loading model:', error);
                                reject(error);
                            }
                        );
                    })
                    .catch(error => {
                        console.warn('Using fallback duck model:', error.message);
                        reject(error);
                    });
            });
        }

        // Create camera with swaying motion
        function createCamera() {
            const camera = new THREE.PerspectiveCamera(
                45, // FOV
                window.innerWidth / window.innerHeight, // Aspect ratio
                0.1, // Near clipping plane
                1000 // Far clipping plane
            );

            // Set initial position
            camera.position.set(-100, 50, -100);
            camera.lookAt(0, 1, 0);

            // Store original position for swaying
            camera.userData.basePosition = camera.position.clone();
            camera.userData.baseTarget = new THREE.Vector3(0, 1, 0);
            camera.userData.swayEnabled = true;
            camera.userData.swayAmplitude = 0.2;
            camera.userData.swaySpeed = 0.5;
            camera.userData.swayTime = 0;

            // Add update function to camera
            camera.update = function(deltaTime) {
                if (!this.userData.swayEnabled) return;

                this.userData.swayTime += deltaTime * this.userData.swaySpeed;

                // Calculate sway offsets
                const swayX = Math.sin(this.userData.swayTime) * this.userData.swayAmplitude;
                const swayY = Math.sin(this.userData.swayTime * 0.7) * this.userData.swayAmplitude * 0.5;
                const swayZ = Math.cos(this.userData.swayTime * 0.3) * this.userData.swayAmplitude * 0.3;

                // Apply sway to position
                this.position.copy(this.userData.basePosition);
                this.position.x += swayX;
                this.position.y += swayY;
                this.position.z += swayZ;

                // Apply slight sway to target
                const target = this.userData.baseTarget.clone();
                target.x += swayX * 0.2;
                target.y += swayY * 0.3;

                this.lookAt(target);
            };

            return camera;
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            if (!isRunning) return;

            const deltaTime = clock.getDelta();

            // Update camera sway
            camera.update(deltaTime);

            // Update cloud system
            cloudSystem.update(deltaTime);

            // Check for cloud hover
            checkCloudHover();

            // Update dialogue position
            updateDialoguePosition();

            // Render scene
            renderer.render(scene, camera);
        }

        // Check for cloud hover
        function checkCloudHover() {
            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Calculate objects intersecting the picking ray
            const intersects = raycaster.intersectObjects(cloudSystem.children, false);

            // Reset previously hovered cloud
            if (hoveredCloud && (!intersects.length || intersects[0].object !== hoveredCloud)) {
                // Only reset if the cloud still exists and hasn't been clicked
                if (hoveredCloud.parent && hoveredCloud.userData.isClickable) {
                    hoveredCloud.material = hoveredCloud.userData.originalMaterial.clone();
                }
                hoveredCloud = null;
                document.body.style.cursor = 'default';
            }

            // Set new hovered cloud
            if (intersects.length > 0) {
                const cloud = intersects[0].object;
                if (cloud.userData.isClickable && cloud.visible) {
                    hoveredCloud = cloud;

                    // Apply hover effect (dark border and more visible)
                    const hoverMaterial = cloud.userData.originalMaterial.clone();
                    hoverMaterial.emissive = new THREE.Color(0x333333);
                    hoverMaterial.emissiveIntensity = 1.0;
                    hoverMaterial.color = new THREE.Color(0xDDDDDD);
                    cloud.material = hoverMaterial;

                    document.body.style.cursor = 'pointer';

                    // Debug info
                    console.log(`Hovering over cloud: ${cloud.name}`);
                }
            }
        }

        // Setup event listeners
        function setupEventListeners() {
            // START button click
            const startButton = document.getElementById('startButton');
            startButton.addEventListener('click', () => {
                // Hide the start button after clicking
                startButton.style.display = 'none';
                const targetPosition = new THREE.Vector3(-25, 4, -35);
                const targetLookAt = new THREE.Vector3(0, 3, 0);
                animateCameraTo(targetPosition, targetLookAt);

                // Make clouds clickable after start button is clicked
                cloudSystem.setClickable(true);

                // Show dialogue after camera animation
                setTimeout(() => {
                    showDialogue("Привет! Как по мне, погода сегодня слишком облачная. Нажимай на облака чтобы они исчезли.");
                }, 1000);
            });

            // Window resize
            window.addEventListener('resize', onWindowResize);

            // Mouse move for hover effect
            window.addEventListener('mousemove', (event) => {
                // Calculate mouse position in normalized device coordinates
                // (-1 to +1) for both components
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            });

            // Mouse click for cloud interaction
            window.addEventListener('click', onMouseClick);
        }

        // Handle mouse click
        function onMouseClick(event) {
            // Only process clicks if the game is running
            if (!isRunning) return;

            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Calculate objects intersecting the picking ray
            const intersects = raycaster.intersectObjects(cloudSystem.children, false);

            if (intersects.length > 0) {
                const cloud = intersects[0].object;

                // Only process clickable clouds
                if (cloud.userData.isClickable && cloud.visible) {
                    // Make cloud disappear
                    cloudSystem.remove(cloud);

                    // Increment counter
                    clickedClouds++;

                    // Check if we've reached 10 clouds
                    if (clickedClouds === 10) {
                        showDialogue("Теперь мне слишком жарко! Продолжение следует.");
                        cloudSystem.setClickable(false);
                        const targetPosition = new THREE.Vector3(10, 4, -35);
                        const targetLookAt = new THREE.Vector3(0, 3, 0);
                        animateCameraTo(targetPosition, targetLookAt);
                    } else {
                        // Update the dialogue bubble with the current count
                        updateCloudCounter();
                    }
                }
            }
        }

        // Initialize dialogue system
        function initDialogueSystem() {
            dialogueBubbleElement = document.getElementById('dialogueBubble');
            cloudCounterElement = document.getElementById('cloudCounter');
        }

        // Show dialogue
        function showDialogue(text) {
            dialogueBubbleElement.textContent = text;
            dialogueBubbleElement.style.opacity = '1';
            dialogueVisible = true;

            // Position the dialogue bubble above the duck
            updateDialoguePosition();
        }

        // Hide dialogue
        function hideDialogue() {
            dialogueBubbleElement.style.opacity = '0';
            dialogueVisible = false;
        }

        // Update dialogue position
        function updateDialoguePosition() {
            if (!dialogueVisible || !duck) return;

            // Get duck position in screen space
            const duckPosition = new THREE.Vector3(0, 6.5, 0); // Approximate position above duck
            const screenPosition = duckPosition.clone();
            screenPosition.project(camera);

            // Convert to CSS coordinates
            const x = (screenPosition.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-(screenPosition.y * 0.5) + 0.5) * window.innerHeight;

            // Update dialogue bubble position
            dialogueBubbleElement.style.left = `${x}px`;
            dialogueBubbleElement.style.top = `${y}px`;
        }

        // Update cloud counter
        function updateCloudCounter() {
            // Update the dialogue bubble text instead of a separate counter
            if (dialogueVisible) {
                showDialogue(`Нажимай на облака: ${clickedClouds} из 10`);
            }
        }

        // Handle window resize
        function onWindowResize() {
            // Update camera aspect ratio
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            // Update renderer size
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
        }

        // Animate camera to game position
        function animateCameraTo(targetPosition, targetLookAt) {
            // Disable camera sway during animation
            camera.userData.swayEnabled = false;

            // Store original values
            const startPosition = camera.position.clone();
            const startTarget = camera.userData.baseTarget.clone();

            // Animation duration
            const duration = 1.0; // Reduce to 1 second for faster animation
            const startTime = performance.now();

            // Animation function
            function animateCamera() {
                const currentTime = performance.now();
                const elapsed = (currentTime - startTime) / 1000; // Convert to seconds
                const t = Math.min(elapsed / duration, 1);

                // Cubic easing
                const ease = t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;

                // Interpolate position
                camera.position.lerpVectors(startPosition, targetPosition, ease);

                // Interpolate target
                const currentTarget = new THREE.Vector3();
                currentTarget.lerpVectors(startTarget, targetLookAt, ease);
                camera.lookAt(currentTarget);

                // Update base values for when sway is re-enabled
                camera.userData.basePosition.copy(camera.position);
                camera.userData.baseTarget.copy(currentTarget);

                // Continue animation if not complete
                if (t < 1) {
                    requestAnimationFrame(animateCamera);
                } else {
                    console.log('Camera animation complete');
                    // Re-enable camera sway if desired
                    // camera.userData.swayEnabled = true;
                }
            }

            // Start animation
            requestAnimationFrame(animateCamera);
        }

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
